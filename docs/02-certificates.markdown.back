# Creando un CA y los certificados TLS 

Es necesario construir una PKI (Private Key
Infrastructure) para generar y firmar los
certificados que usaran los siguientes componentes
`kube-apiserver`, `etcd`, `kube-controller`,
`kube-scheduler`, `kubelet`, y `kube-proxy`; Para
esto vamos a utilizar `openssl`

## CA

Empezaremos generando un CA para firmar los
subsecuentes certificados

```bash
# creamos una carpeta para guardar los
# certificados
mkdir ca
# generamos una llave para los ceritificados
openssl genrsa -out ca/ca.key 2048
# generamos una peticion de firma de certificado
openssl req -new -key ca/ca.key -subj "/CN=KUBERNETES-CA" -out ca.csr
# auto-firmamos nuestro certificado
openssl x509 -req -in ca.csr -signkey ca/ca.key -CAcreateserial -out ca/ca.rt -days 1000
```

## Certificados para Cliente/Servidor
Vamos a crear los certificados cliente/servidor
para cada component y un certificado para el
usuario `admin` de Kubernetes

Vamos a crear la siguiente funcion en nuestra sesion de shell para hacer mas facil el proceso de creaci贸n de los certificados

```bash
gen_cmp_cert () {
  COMPONENT=$1
  KEY=${COMPONENT}/${COMPONENT}.key
  CRT=${COMPONENT}/${COMPONENT}.crt
  CSR=${COMPONENT}.csr
  ROLE=$2
  CONF=$4

  if [ -z "${CONF}" ]
  then
    CRT_CMD="openssl x509 -req -in ${CSR} -CA ca/ca.crt -CAkey ca/ca.key -CAcreateserial -out ${CRT} -days $3"
  else
    CRT_CMD="openssl x509 -req -in ${CSR} -CA ca/ca.crt -CAkey ca/ca.key -CAcreateserial -out ${CRT} \
             -extensions v3_req -extfile ${CONF} -days $3"
  fi

  mkdir ${COMPONENT}

  openssl genrsa -out ${KEY} 2048
  openssl req -new -key ${KEY} -subj "/CN=${ROLE}" -out ${CSR}
  $CRT_CMD
}

```

### Forma de uso
```bash
gen_cmp_cert <componente> <rol> <dias de validez> [configuracion]
```

## Certificados para cliente y servidor


### Certificados para el usuario admin
```bash
gen_cmp_cert admin admin/O=system:masters 1000
```
Note que el usuario admin es parte del grupo
**system:masters**, eso es lo que hace posible
realizar tareas administrativas usando `kubectl`

### Certificados para el cliente del Controller mgr
```bash
gen_cmp_cert kube-controller-manager system:kube-controller-manager 1000
```
### Certificados para kube-proxy
```bash
gen_cmp_cert kube-proxy system:kube-proxy 1000
```
### Certificados para kube-scheduler
```bash
gen_cmp_cert kube-scheduler system:kube-scheduler 1000
```
### Certificados para kube-apiserver
Para estos certificados necesitamos agregar nombres y direcciones alternativas con las que se
puede contactar al kube-apiserver, esto no es posible hacerlo via parametros del comando openssl
por lo que necesitamos crear un archivo de configuraci贸n.

```
cat > openssl.cnf <<EOF
[req]
req_extensions = v3_req
distinguished_name = req_distinguished_name
[req_distinguished_name]
[ v3_req ]
basicConstraints = CA:FALSE
keyUsage = nonRepudiation, digitalSignature, keyEncipherment
subjectAltName = @alt_names
[alt_names]
DNS.1 = kubernetes
DNS.2 = kubernetes.default
DNS.3 = kubernetes.default.svc
DNS.4 = kubernetes.default.svc.cluster.local
IP.1 = 10.96.0.1
IP.2 = 192.168.5.11
IP.4 = 192.168.5.30
IP.5 = 127.0.0.1
EOF

gen_cmp_cert kube-apiserver kube-apiserver 1000 openssl.conf
```

### Certificados para ETCD (base de datos)

Al igual que kube-apiserver este servicio requiere de una configuraci贸n especial para agregar nombres alternativos

```bash
cat > openssl-etcd.cnf <<EOF
[req]
req_extensions = v3_req
distinguished_name = req_distinguished_name
[req_distinguished_name]
[ v3_req ]
basicConstraints = CA:FALSE
keyUsage = nonRepudiation, digitalSignature, keyEncipherment
subjectAltName = @alt_names
[alt_names]
IP.1 = 192.168.5.11
IP.2 = 127.0.0.1
EOF

gen_cmp_cert etcd-server etcd-server 1000 openssl-etcd.cnf
```
### ceritificados para la cuenta de servicios
```bash
gen_cmp_cert service-account service-account 1000
```

### Organizaci贸n de archivos
Organizamos nuestos directirios
```bash
mkdir csr
mv *.csr $_
mkdir confs
mv *.conf *.cnf $_

ls -la
```
